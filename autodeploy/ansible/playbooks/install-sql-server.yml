---
# install-sql-server.yml — Installa SQL Server 2025 Enterprise (unattended) su Windows target.
#
# NOTA: Richiede che l'ISO/media di SQL Server sia accessibile dal nodo.
#       La variabile sql_iso_url punta alla risorsa scaricabile (storage blob, file share, ecc.)
#       In alternativa, la variabile sql_setup_path può puntare a un path locale.
#
# Uso:
#   ansible-playbook -i inventory/terraform.yml playbooks/install-sql-server.yml \
#       -e sql_iso_url=https://... -e sql_sa_password=...

- name: Install SQL Server (unattended)
  hosts: windows
  gather_facts: false

  vars:
    sql_iso_url: ""                         # override via -e o group_vars
    sql_setup_path: "C:\\SQLSetup"          # working directory
    sql_instance_name: "MSSQLSERVER"        # default instance
    sql_sa_password: "{{ ansible_password }}"
    sql_features: "SQLENGINE,REPLICATION,FULLTEXT"
    sql_collation: "Latin1_General_CI_AS"
    sql_svc_account: "NT Service\\MSSQLSERVER"
    sql_agent_svc_account: "NT Service\\SQLSERVERAGENT"

  tasks:
    - name: Crea cartella setup
      ansible.windows.win_file:
        path: "{{ sql_setup_path }}"
        state: directory

    - name: Download SQL Server ISO (se sql_iso_url fornito)
      ansible.windows.win_get_url:
        url: "{{ sql_iso_url }}"
        dest: "{{ sql_setup_path }}\\SQLServer.iso"
        force: false
      when: sql_iso_url | length > 0

    - name: Monta ISO
      ansible.windows.win_powershell:
        script: |
          $iso = "{{ sql_setup_path }}\SQLServer.iso"
          if (Test-Path $iso) {
              $mount = Mount-DiskImage -ImagePath $iso -PassThru
              $drive = ($mount | Get-Volume).DriveLetter
              Write-Output $drive
          } else {
              Write-Error "ISO not found: $iso"
              exit 1
          }
      register: mount_result
      when: sql_iso_url | length > 0

    - name: Prepara script di setup SQL Server e Scheduled Task (DPAPI workaround)
      ansible.windows.win_powershell:
        script: |
          # WinRM sessions use "Network" logon — DPAPI ProtectedData.Protect() fails
          # because no user profile/master key is loaded.
          # Workaround: write a setup script to disk, run it via Scheduled Task
          # (which uses "Batch" logon → DPAPI works).

          $setupDrive = "{{ mount_result.output[0] | default('D') }}"
          $setupExe = "${setupDrive}:\setup.exe"
          if (-not (Test-Path $setupExe)) {
              $setupExe = "{{ sql_setup_path }}\setup.exe"
          }
          if (-not (Test-Path $setupExe)) {
              Write-Error "setup.exe not found"
              exit 1
          }

          $logDir = "C:\Windows\Temp\SQLSetup"
          if (-not (Test-Path $logDir)) { New-Item -Path $logDir -ItemType Directory -Force | Out-Null }

          # Write the setup wrapper script
          $scriptContent = @"
          `$env:TEMP = "$logDir"
          `$env:TMP  = "$logDir"
          `$proc = Start-Process -FilePath "$setupExe" -ArgumentList @(
              '/Q',
              '/IACCEPTSQLSERVERLICENSETERMS',
              '/ACTION=Install',
              '/FEATURES={{ sql_features }}',
              '/INSTANCENAME={{ sql_instance_name }}',
              '/SQLSVCACCOUNT="{{ sql_svc_account }}"',
              '/AGTSVCACCOUNT="{{ sql_agent_svc_account }}"',
              '/SQLSYSADMINACCOUNTS="BUILTIN\Administrators"',
              '/SECURITYMODE=SQL',
              '/SAPWD="{{ sql_sa_password }}"',
              '/SQLCOLLATION={{ sql_collation }}',
              '/TCPENABLED=1',
              '/NPENABLED=0',
              '/UpdateEnabled=False',
              '/ENU'
          ) -Wait -PassThru -NoNewWindow
          `$proc.ExitCode | Out-File -FilePath "$logDir\exitcode.txt" -Encoding ascii
          "@

          $scriptPath = "$logDir\run_sql_setup.ps1"
          Set-Content -Path $scriptPath -Value $scriptContent -Encoding UTF8
          Write-Output $scriptPath

    - name: Installa SQL Server via Scheduled Task (DPAPI-safe)
      ansible.windows.win_powershell:
        script: |
          $taskName  = "AnsibleSQLSetup"
          $scriptPath = "C:\Windows\Temp\SQLSetup\run_sql_setup.ps1"
          $exitFile   = "C:\Windows\Temp\SQLSetup\exitcode.txt"

          # Cleanup any previous run
          if (Test-Path $exitFile) { Remove-Item $exitFile -Force }
          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue

          # Create and run scheduled task as localadmin (Batch logon → DPAPI works)
          $action  = New-ScheduledTaskAction -Execute "powershell.exe" `
              -Argument "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`""
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
          Register-ScheduledTask -TaskName $taskName -Action $action -Settings $settings `
              -User "{{ ansible_user }}" -Password "{{ ansible_password }}" `
              -RunLevel Highest -Force | Out-Null

          Start-ScheduledTask -TaskName $taskName
          Write-Output "Scheduled task started — waiting for SQL Setup to finish..."

          # Poll until the task is no longer Running (timeout: 50 min)
          $timeout = [DateTime]::UtcNow.AddMinutes(50)
          do {
              Start-Sleep -Seconds 15
              $info = Get-ScheduledTaskInfo -TaskName $taskName -ErrorAction SilentlyContinue
              $state = (Get-ScheduledTask -TaskName $taskName).State
              Write-Output "  state=$state ($(([DateTime]::UtcNow).ToString('HH:mm:ss')))"
          } while ($state -eq 'Running' -and [DateTime]::UtcNow -lt $timeout)

          # Cleanup task
          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue

          # Read exit code
          if (-not (Test-Path $exitFile)) {
              Write-Error "SQL Setup did not produce an exit code (timeout or crash)"
              exit 1
          }

          $exitCode = [int](Get-Content $exitFile -Raw).Trim()
          Write-Output "SQL Setup exit code: $exitCode"

          if ($exitCode -notin @(0, 3010)) {
              $summaryPath = Get-ChildItem "C:\Program Files\Microsoft SQL Server\*\Setup Bootstrap\Log\Summary.txt" `
                  -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
              if ($summaryPath) {
                  Write-Output "=== Summary.txt ==="
                  Get-Content $summaryPath.FullName -Tail 60
                  Write-Output "=== End Summary.txt ==="
              }
              Write-Error "SQL Setup failed with exit code $exitCode"
              exit 1
          }

          if ($exitCode -eq 3010) { Write-Output "REBOOT_REQUIRED" }
          Write-Output "SQL Server installed successfully"
      register: sql_install
      timeout: 3600

    - name: Reboot se richiesto (exit code 3010)
      ansible.windows.win_reboot:
        reboot_timeout: 600
      when: "'REBOOT_REQUIRED' in (sql_install.output | default(['']) | join(''))"

    - name: Verifica servizio SQL Server
      ansible.windows.win_service:
        name: "MSSQL${{ sql_instance_name if sql_instance_name != 'MSSQLSERVER' else '' }}"
        state: started
        start_mode: auto
      register: sqlsvc
      when: sql_instance_name != 'MSSQLSERVER'

    - name: Verifica servizio SQL Server (default instance)
      ansible.windows.win_service:
        name: MSSQLSERVER
        state: started
        start_mode: auto
      register: sqlsvc_default
      when: sql_instance_name == 'MSSQLSERVER'

    - name: Mostra stato SQL Server
      ansible.builtin.debug:
        msg: "SQL Server {{ sql_instance_name }} installed and running."

    - name: Cleanup — smonta ISO
      ansible.windows.win_powershell:
        script: |
          $iso = "{{ sql_setup_path }}\SQLServer.iso"
          if (Test-Path $iso) { Dismount-DiskImage -ImagePath $iso -ErrorAction SilentlyContinue }
      when: sql_iso_url | length > 0
      ignore_errors: true
