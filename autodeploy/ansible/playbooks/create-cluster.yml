---
# create-cluster.yml — Crea WSFC + configura SQL Always On AG.
#
# ARCHITETTURA: Tutte le operazioni cluster/AG vengono eseguite tramite
# Scheduled Task (logon Batch) con account di dominio perché:
#   1. I cmdlet FailoverClusters richiedono delegazione credenziali
#      che WinRM/NTLM non supporta (double-hop problem).
#   2. Le operazioni cluster richiedono un account di dominio (Domain Admin).
#   3. Il logon Batch fornisce un token completo con Kerberos TGT delegabile.
#
# Pre-requisiti gestiti dal playbook:
#   - SeBatchLogonRight per domain_user
#   - ACL FullControl sulla cartella di lavoro
#   - Start-Transcript per diagnostica
#
# Variabili richieste (passate via -e):
#   cluster_name, cluster_ip, node1_name, node2_name,
#   ag_name, listener_name, domain_user, domain_password,
#   storage_account_name, storage_account_key

- name: Create WSFC Cluster + SQL Always On AG
  hosts: windows
  gather_facts: false

  vars:
    cluster_name: ""
    cluster_ip: ""
    node1_name: ""
    node2_name: ""
    ag_name: ""
    listener_name: ""
    listener_port: "1433"
    storage_account_name: ""
    storage_account_key: ""
    domain_user: ""
    domain_password: ""
    work_dir: 'C:\Windows\Temp\ClusterSetup'
    # Derived
    node1_fqdn: "{{ node1_name }}.fabmas.it"
    node2_fqdn: "{{ node2_name }}.fabmas.it"

  tasks:
    # ---- 0. Prepara ambiente ----
    - name: Crea cartella di lavoro
      ansible.windows.win_file:
        path: "{{ work_dir }}"
        state: directory

    - name: Concedi SeBatchLogonRight e ACL al domain user
      ansible.windows.win_powershell:
        script: |
          $domainUser = "{{ domain_user }}"
          $workDir    = "{{ work_dir }}"

          # --- 1. Grant SeBatchLogonRight ---
          try {
              $sid = (New-Object System.Security.Principal.NTAccount($domainUser)).Translate(
                  [System.Security.Principal.SecurityIdentifier]).Value
              Write-Output "Domain user SID: $sid"

              $tmpCfg = "$env:TEMP\secpol_export_$((Get-Random)).cfg"
              $tmpDb  = "$env:TEMP\secpol_$((Get-Random)).sdb"

              secedit /export /cfg $tmpCfg /quiet | Out-Null
              $content = Get-Content $tmpCfg -Raw

              if ($content -match 'SeBatchLogonRight\s*=\s*(.*)') {
                  $existing = $Matches[0]
                  if ($existing -notmatch [regex]::Escape($sid)) {
                      $content = $content -replace [regex]::Escape($existing), "$existing,*$sid"
                      Write-Output "Appended $domainUser to SeBatchLogonRight"
                  } else {
                      Write-Output "SeBatchLogonRight already contains $domainUser"
                  }
              } else {
                  $content = $content -replace '(\[Privilege Rights\])', "`$1`r`nSeBatchLogonRight = *$sid"
                  Write-Output "Added SeBatchLogonRight for $domainUser"
              }

              Set-Content $tmpCfg $content -Encoding ASCII
              secedit /configure /db $tmpDb /cfg $tmpCfg /quiet | Out-Null
              Remove-Item $tmpCfg, $tmpDb -Force -ErrorAction SilentlyContinue
              Write-Output "SeBatchLogonRight: OK"
          } catch {
              Write-Output "WARNING: SeBatchLogonRight grant failed — $($_.Exception.Message)"
              # Might already work via Domain Admins → Administrators group
          }

          # --- 2. ACL FullControl on work directory ---
          $acl  = Get-Acl $workDir
          $rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
              $domainUser, "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow")
          $acl.SetAccessRule($rule)
          Set-Acl $workDir $acl
          Write-Output "ACL FullControl on ${workDir} for ${domainUser}: OK"

    # ---- 1. Scrivi lo script completo di setup ----
    - name: Scrivi script di setup cluster + AG
      ansible.windows.win_copy:
        dest: "{{ work_dir }}\\setup_cluster.ps1"
        content: |
          # Transcript per diagnostica (cattura TUTTO anche se lo script crasha)
          Start-Transcript -Path "C:\Windows\Temp\ClusterSetup\transcript.log" -Force

          $ErrorActionPreference = 'Stop'
          $logFile  = "C:\Windows\Temp\ClusterSetup\cluster_setup.log"
          $exitFile = "C:\Windows\Temp\ClusterSetup\exitcode.txt"

          function Log { param([string]$msg)
            $ts = Get-Date -Format 'HH:mm:ss'
            $line = "$ts  $msg"
            Add-Content -Path $logFile -Value $line
            Write-Host $line
          }

          try {
              Log "=== Cluster + AG Setup ==="
              Log "Running as: $env:USERDOMAIN\$env:USERNAME"
              Log "Logon type test: whoami=$(whoami)"
              Log "Node1: {{ node1_fqdn }}  Node2: {{ node2_fqdn }}"
              Log "Cluster: {{ cluster_name }} ({{ cluster_ip }})"
              Log "AG: {{ ag_name }}   Listener(DNN): {{ listener_name }}"

              # ---- Phase 0: Prerequisites ----
              Log "--- Phase 0: Prerequisites ---"
              Log "Testing PSRemoting to {{ node2_fqdn }}..."
              $r = Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock { hostname }
              Log "PSRemoting OK -- {{ node2_fqdn }} returned: $r"

              # Open firewall ports on both nodes
              foreach ($port in @(1433, 5022)) {
                  $ruleName = "SQL-$port"
                  New-NetFirewallRule -DisplayName $ruleName -Direction Inbound -LocalPort $port -Protocol TCP -Action Allow -ErrorAction SilentlyContinue | Out-Null
                  Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock {
                      param($n,$p)
                      New-NetFirewallRule -DisplayName $n -Direction Inbound -LocalPort $p -Protocol TCP -Action Allow -ErrorAction SilentlyContinue | Out-Null
                  } -ArgumentList $ruleName, $port
              }
              Log "Firewall rules (1433, 5022) OK on both nodes"

              # ---- Phase 1: Cluster Validation ----
              Log "--- Phase 1: Cluster Validation ---"
              Test-Cluster -Node "{{ node1_fqdn }}", "{{ node2_fqdn }}" -Include "Storage","Network","Inventory","Configuration" -ErrorAction Stop | Out-Null
              Log "Phase 1: PASSED"

              # ---- Phase 2: Create WSFC Cluster ----
              Log "--- Phase 2: Create WSFC Cluster ---"
              $clusterObj = $null
              try { $clusterObj = Get-Cluster -Name "{{ cluster_name }}" -ErrorAction Stop } catch {}
              if ($clusterObj) {
                  Log "Cluster '{{ cluster_name }}' already exists -- skip"
              } else {
                  New-Cluster -Name "{{ cluster_name }}" `
                      -Node "{{ node1_fqdn }}", "{{ node2_fqdn }}" `
                      -StaticAddress "{{ cluster_ip }}" `
                      -NoStorage -ErrorAction Stop
                  Log "Cluster '{{ cluster_name }}' created"
              }

              # Verify cluster IP is online
              $clusterUp = Get-Cluster -Name "{{ cluster_name }}" -ErrorAction Stop
              Log "Cluster '$($clusterUp.Name)' state OK"
              $ipRes = Get-ClusterResource -Cluster "{{ cluster_name }}" | Where-Object { $_.ResourceType -eq 'IP Address' }
              foreach ($ip in $ipRes) {
                  $addr = ($ip | Get-ClusterParameter -Name 'Address').Value
                  Log "Cluster IP resource: $($ip.Name) = $addr  State=$($ip.State)"
              }
              $nodes = Get-ClusterNode -Cluster "{{ cluster_name }}"
              foreach ($n in $nodes) {
                  Log "Cluster node: $($n.Name)  State=$($n.State)"
                  if ($n.State -ne 'Up') { throw "Cluster node $($n.Name) is not Up ($($n.State))" }
              }
              Log "Phase 2: Cluster VERIFIED"

              # ---- Phase 3: Cloud Witness ----
              $saName = "{{ storage_account_name }}"
              $saKey  = "{{ storage_account_key }}"
              if ($saName -and $saKey) {
                  Log "--- Phase 3: Cloud Witness ---"
                  Set-ClusterQuorum -Cluster "{{ cluster_name }}" `
                      -CloudWitness -AccountName $saName -AccessKey $saKey -ErrorAction Stop
                  Log "Cloud Witness configured ($saName)"
              } else {
                  Log "--- Phase 3: Cloud Witness --- SKIPPED"
              }

              # ---- Phase 4: Enable SQL Always On ----
              Log "--- Phase 4: Enable SQL Always On ---"

              # Install SqlServer module on BOTH nodes
              $installModuleBlock = {
                  if (-not (Get-Module -ListAvailable SqlServer -ErrorAction SilentlyContinue)) {
                      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                      Install-PackageProvider -Name NuGet -Force -Scope AllUsers -ErrorAction SilentlyContinue | Out-Null
                      Install-Module SqlServer -Force -AllowClobber -Scope AllUsers -ErrorAction Stop
                  }
                  Import-Module SqlServer -ErrorAction Stop
              }

              # Node 1 — local
              & $installModuleBlock
              Log "SqlServer module loaded on {{ node1_name }} (local)"

              # Node 2 — remote
              Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock $installModuleBlock -ErrorAction Stop
              Log "SqlServer module loaded on {{ node2_name }} (remote)"

              # Enable AlwaysOn LOCALLY on node1 ($env:COMPUTERNAME)
              Log "Enabling AlwaysOn on {{ node1_name }} (local)..."
              Enable-SqlAlwaysOn -ServerInstance $env:COMPUTERNAME -Force -ErrorAction Stop
              Log "AlwaysOn enabled + SQL restarted on {{ node1_name }}"

              # Enable AlwaysOn LOCALLY on node2 via Invoke-Command
              Log "Enabling AlwaysOn on {{ node2_name }} (remote Invoke-Command)..."
              Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock {
                  Import-Module SqlServer -ErrorAction Stop
                  Enable-SqlAlwaysOn -ServerInstance $env:COMPUTERNAME -Force -ErrorAction Stop
              } -ErrorAction Stop
              Log "AlwaysOn enabled + SQL restarted on {{ node2_name }}"

              # Wait for SQL to come back online on both nodes
              foreach ($inst in @("{{ node1_fqdn }}", "{{ node2_fqdn }}")) {
                  Log "Waiting for SQL on $inst..."
                  for ($retry = 1; $retry -le 30; $retry++) {
                      Start-Sleep -Seconds 5
                      try {
                          Invoke-Sqlcmd -ServerInstance $inst -Query "SELECT 1" -ErrorAction Stop | Out-Null
                          Log "SQL $inst is ONLINE"
                          break
                      } catch {
                          if ($retry -eq 30) { throw "SQL Server $inst not ready after 150 s" }
                      }
                  }
              }

              # VALIDATE: AlwaysOn is actually enabled (IsHadrEnabled = 1)
              foreach ($inst in @("{{ node1_fqdn }}", "{{ node2_fqdn }}")) {
                  $hadr = (Invoke-Sqlcmd -ServerInstance $inst -Query "SELECT SERVERPROPERTY('IsHadrEnabled') AS V").V
                  if ($hadr -ne 1) {
                      throw "FATAL: AlwaysOn is NOT enabled on $inst (IsHadrEnabled=$hadr). Check SQL Configuration Manager."
                  }
                  Log "VERIFIED: AlwaysOn enabled on $inst (IsHadrEnabled=$hadr)"
              }
              Log "Phase 4: DONE"

              # ---- Phase 5: Availability Group ----
              Log "--- Phase 5: Availability Group ---"
              $existingAg = $null
              try {
                  $existingAg = Get-ChildItem "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT\AvailabilityGroups" `
                      -ErrorAction Stop | Where-Object { $_.Name -eq "{{ ag_name }}" }
              } catch {}

              if ($existingAg) {
                  Log "AG '{{ ag_name }}' already exists -- skip"
              } else {
                  # Hadr endpoint -- node 1
                  try {
                      $ep1 = New-SqlHadrEndpoint -Path "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT" `
                          -Name "Hadr_endpoint" -Port 5022 -ErrorAction Stop
                      Set-SqlHadrEndpoint -Path "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT\Endpoints\Hadr_endpoint" -State Started
                  } catch { Log "Hadr_endpoint node1: $($_.Exception.Message) (may exist)" }
                  Log "Hadr_endpoint {{ node1_fqdn }} OK"

                  # Hadr endpoint -- node 2
                  $ep2Q = "IF NOT EXISTS (SELECT 1 FROM sys.endpoints WHERE name='Hadr_endpoint') " +
                          "CREATE ENDPOINT Hadr_endpoint STATE=STARTED AS TCP(LISTENER_PORT=5022) " +
                          "FOR DATABASE_MIRRORING(ROLE=ALL, AUTHENTICATION=WINDOWS NEGOTIATE, ENCRYPTION=REQUIRED ALGORITHM AES)"
                  Invoke-Sqlcmd -ServerInstance "{{ node2_fqdn }}" -Query $ep2Q
                  Log "Hadr_endpoint {{ node2_fqdn }} OK"

                  # SQL major version (auto-detect)
                  $sqlVer = [int](Invoke-Sqlcmd -ServerInstance "{{ node1_fqdn }}" `
                      -Query "SELECT CAST(SERVERPROPERTY('ProductMajorVersion') AS INT) AS V").V
                  Log "SQL major version: $sqlVer"

                  $primary = New-SqlAvailabilityReplica -Name "{{ node1_fqdn }}" `
                      -EndpointUrl "TCP://{{ node1_fqdn }}:5022" `
                      -AvailabilityMode SynchronousCommit -FailoverMode Automatic `
                      -AsTemplate -Version $sqlVer
                  $secondary = New-SqlAvailabilityReplica -Name "{{ node2_fqdn }}" `
                      -EndpointUrl "TCP://{{ node2_fqdn }}:5022" `
                      -AvailabilityMode SynchronousCommit -FailoverMode Automatic `
                      -AsTemplate -Version $sqlVer

                  New-SqlAvailabilityGroup -Name "{{ ag_name }}" `
                      -Path "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT" `
                      -AvailabilityReplica @($primary, $secondary) -ErrorAction Stop
                  Log "AG '{{ ag_name }}' created"

                  # Join node 2
                  Join-SqlAvailabilityGroup -Path "SQLSERVER:\SQL\{{ node2_fqdn }}\DEFAULT" `
                      -Name "{{ ag_name }}" -ErrorAction Stop
                  Log "{{ node2_fqdn }} joined AG"
              }
              Log "Phase 5: DONE"

              # ---- Phase 6: DNN Listener ----
              Log "--- Phase 6: DNN Listener ---"
              $existingLsn = $null
              try {
                  $existingLsn = Get-ChildItem "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT\AvailabilityGroups\{{ ag_name }}\AvailabilityGroupListeners" `
                      -ErrorAction Stop | Where-Object { $_.Name -eq "{{ listener_name }}" }
              } catch {}

              if ($existingLsn) {
                  Log "DNN Listener '{{ listener_name }}' already exists -- skip"
              } else {
                  $lsnQ = "ALTER AVAILABILITY GROUP [{{ ag_name }}] ADD LISTENER N'{{ listener_name }}' " +
                          "(WITH DISTRIBUTED_NETWORK_NAME, WITH IP (NONE), PORT = {{ listener_port }})"
                  Invoke-Sqlcmd -ServerInstance "{{ node1_fqdn }}" -Query $lsnQ
                  Log "DNN Listener '{{ listener_name }}' port {{ listener_port }}"
              }
              Log "Phase 6: DONE"

              Log "=== ALL PHASES COMPLETED ==="
              "0" | Out-File -FilePath $exitFile -Encoding ascii

          } catch {
              Log "FATAL: $($_.Exception.Message)"
              Log "Stack: $($_.ScriptStackTrace)"
              "1" | Out-File -FilePath $exitFile -Encoding ascii
          } finally {
              Stop-Transcript -ErrorAction SilentlyContinue
          }

    # ---- 1a. Riscrivi PS1 con BOM UTF-8 (PowerShell 5.1 legge ANSI senza BOM) ----
    - name: Riscrivi PS1 con BOM UTF-8
      ansible.windows.win_powershell:
        script: |
          $path = "{{ work_dir }}\setup_cluster.ps1"
          $content = [System.IO.File]::ReadAllText($path, [System.Text.Encoding]::UTF8)
          $utf8Bom = New-Object System.Text.UTF8Encoding $true
          [System.IO.File]::WriteAllText($path, $content, $utf8Bom)
          $info = Get-Item $path
          Write-Output "Rewritten with UTF-8 BOM: $path ($($info.Length) bytes)"

    # ---- 1b. Valida sintassi PS1 ----
    - name: Valida sintassi script PS1
      ansible.windows.win_powershell:
        script: |
          $scriptPath = "{{ work_dir }}\setup_cluster.ps1"
          if (-not (Test-Path $scriptPath)) {
              Write-Error "PS1 not found: $scriptPath"; exit 1
          }
          $info = Get-Item $scriptPath
          Write-Output "PS1: $scriptPath ($($info.Length) bytes)"
          $errors = $null; $tokens = $null
          [System.Management.Automation.Language.Parser]::ParseFile(
              $scriptPath, [ref]$tokens, [ref]$errors) | Out-Null
          if ($errors.Count -gt 0) {
              Write-Output "=== SYNTAX ERRORS ==="
              foreach ($e in $errors) {
                  Write-Output "  Line $($e.Extent.StartLineNumber): $($e.Message)"
              }
              $raw = Get-Content $scriptPath -Raw
              Write-Output "=== First 500 chars ==="
              Write-Output $raw.Substring(0, [Math]::Min(500, $raw.Length))
              Write-Output "==="
              Write-Error "PS1 has $($errors.Count) syntax error(s)"
              exit 1
          }
          Write-Output "Syntax OK ($($tokens.Count) tokens)"
      register: ps1_check

    - name: Mostra validazione PS1
      ansible.builtin.debug:
        msg: "{{ ps1_check.output | default(['N/A']) }}"

    # ---- 2. Esegui via Scheduled Task ----
    - name: Esegui setup cluster via Scheduled Task (WinRM double-hop workaround)
      ansible.windows.win_powershell:
        script: |
          $taskName     = "AnsibleClusterSetup"
          $workDir      = "{{ work_dir }}"
          $scriptPath   = "$workDir\setup_cluster.ps1"
          $exitFile     = "$workDir\exitcode.txt"
          $logFile      = "$workDir\cluster_setup.log"
          $transcript   = "$workDir\transcript.log"
          $launcherPath = "$workDir\launcher.cmd"
          $outputLog    = "$workDir\task_output.log"

          # Cleanup previous run
          foreach ($f in @($exitFile, $logFile, $transcript, $launcherPath, $outputLog)) {
            if (Test-Path $f) { Remove-Item $f -Force }
          }
          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue

          # Write cmd launcher — captures ALL PowerShell output including parse errors
          $launcherContent = @"
          @echo off
          powershell.exe -NoProfile -ExecutionPolicy Bypass -File "$scriptPath" > "$outputLog" 2>&1
          "@
          Set-Content -Path $launcherPath -Value $launcherContent -Encoding ASCII
          Write-Output "Launcher: $launcherPath"
          Get-Content $launcherPath | ForEach-Object { Write-Output "  $_" }

          # Register task with domain credentials (Batch logon → Kerberos TGT)
          $action   = New-ScheduledTaskAction -Execute "cmd.exe" `
              -Argument "/c `"$launcherPath`"" `
              -WorkingDirectory $workDir
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries `
              -DontStopIfGoingOnBatteries -ExecutionTimeLimit (New-TimeSpan -Minutes 40)
          Register-ScheduledTask -TaskName $taskName -Action $action -Settings $settings `
              -User "{{ domain_user }}" -Password "{{ domain_password }}" `
              -RunLevel Highest -Force | Out-Null

          Start-ScheduledTask -TaskName $taskName
          Write-Output "Scheduled task started — cluster setup in progress..."

          # Give the task a moment to actually start
          Start-Sleep -Seconds 5

          # Poll (max 35 min)
          $deadline = [DateTime]::UtcNow.AddMinutes(35)
          $firstPoll = $true
          do {
              if (-not $firstPoll) { Start-Sleep -Seconds 15 }
              $firstPoll = $false

              $task  = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
              $info  = Get-ScheduledTaskInfo -TaskName $taskName -ErrorAction SilentlyContinue
              $state = $task.State
              $lastResult = if ($info) { "0x{0:X}" -f $info.LastTaskResult } else { "N/A" }
              $tail  = ""
              if (Test-Path $logFile) {
                  $tail = (Get-Content $logFile -Tail 1)
              } elseif (Test-Path $outputLog) {
                  $tail = (Get-Content $outputLog -Tail 1)
              }
              Write-Output "  [state=$state result=$lastResult] $tail"

              if ($state -ne 'Running') {
                  Write-Output "Task finished (state=$state, lastResult=$lastResult)"
                  break
              }
          } while ([DateTime]::UtcNow -lt $deadline)

          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue

          # Show cluster setup log (written by PS1 script)
          if (Test-Path $logFile) {
              Write-Output "=== Cluster Setup Log ==="
              Get-Content $logFile
              Write-Output "=== End Log ==="
          }

          # Show task output (cmd wrapper captured stdout+stderr including parse errors)
          if (Test-Path $outputLog) {
              Write-Output "=== Task Output (cmd wrapper) ==="
              Get-Content $outputLog
              Write-Output "=== End Task Output ==="
          }

          # Show transcript
          if (Test-Path $transcript) {
              Write-Output "=== Transcript ==="
              Get-Content $transcript -Tail 50
              Write-Output "=== End Transcript ==="
          }

          # Determine result
          if (-not (Test-Path $exitFile)) {
              Write-Output "=== Task Scheduler Event Log (last 5) ==="
              Get-WinEvent -LogName "Microsoft-Windows-TaskScheduler/Operational" -MaxEvents 5 |
                  Where-Object { $_.Message -match $taskName } |
                  ForEach-Object { Write-Output "$($_.TimeCreated) [$($_.Id)] $($_.Message)" }
              Write-Output "=== End Event Log ==="
              Write-Error "Cluster setup did not produce exit code — see logs above"
              exit 1
          }

          $ec = [int](Get-Content $exitFile -Raw).Trim()
          Write-Output "Exit code: $ec"
          if ($ec -ne 0) { Write-Error "Cluster setup failed — see log above"; exit 1 }
          Write-Output "Cluster + AG setup completed successfully"
      register: cluster_setup
      timeout: 2400

    - name: Mostra output completo
      ansible.builtin.debug:
        msg: "{{ cluster_setup.output | default(['N/A']) }}"

    # ---- 3. Riepilogo ----
    - name: Riepilogo finale
      ansible.builtin.debug:
        msg: |
          === Cluster + AG Summary ===
          Cluster:       {{ cluster_name }} ({{ cluster_ip }})
          Nodes:         {{ node1_fqdn }}, {{ node2_fqdn }}
          Cloud Witness: {{ storage_account_name | default('N/A') }}
          AG:            {{ ag_name }}
          DNN Listener:  {{ listener_name }} (port {{ listener_port }})
          Connection:    Server={{ listener_name }},{{ listener_port }};MultiSubnetFailover=True
