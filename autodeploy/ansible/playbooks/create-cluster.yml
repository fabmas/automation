---
# create-cluster.yml — Crea WSFC + configura SQL Always On AG.
#
# ARCHITETTURA: Tutte le operazioni cluster/AG vengono eseguite tramite
# Scheduled Task (logon Batch) con account di dominio perché:
#   1. I cmdlet FailoverClusters richiedono delegazione credenziali
#      che WinRM/NTLM non supporta (double-hop problem).
#   2. Le operazioni cluster richiedono un account di dominio (Domain Admin).
#   3. Il logon Batch fornisce un token completo con Kerberos TGT delegabile.
#
# Pre-requisiti gestiti dal playbook:
#   - SeBatchLogonRight per domain_user
#   - ACL FullControl sulla cartella di lavoro
#   - Start-Transcript per diagnostica
#
# Variabili richieste (passate via -e):
#   cluster_name, cluster_ip, node1_name, node2_name,
#   ag_name, listener_name, domain_user, domain_password,
#   storage_account_name, storage_account_key

- name: Create WSFC Cluster + SQL Always On AG
  hosts: windows
  gather_facts: false

  vars:
    cluster_name: ""
    cluster_ip: ""
    node1_name: ""
    node2_name: ""
    ag_name: ""
    listener_name: ""
    listener_port: "1433"
    storage_account_name: ""
    storage_account_key: ""
    domain_user: ""
    domain_password: ""
    work_dir: 'C:\Windows\Temp\ClusterSetup'
    # Derived
    node1_fqdn: "{{ node1_name }}.fabmas.it"
    node2_fqdn: "{{ node2_name }}.fabmas.it"

  tasks:
    # ---- 0. Prepara ambiente ----
    - name: Crea cartella di lavoro
      ansible.windows.win_file:
        path: "{{ work_dir }}"
        state: directory

    - name: Concedi SeBatchLogonRight e ACL al domain user
      ansible.windows.win_powershell:
        script: |
          $domainUser = "{{ domain_user }}"
          $workDir    = "{{ work_dir }}"

          # --- 1. Grant SeBatchLogonRight ---
          try {
              $sid = (New-Object System.Security.Principal.NTAccount($domainUser)).Translate(
                  [System.Security.Principal.SecurityIdentifier]).Value
              Write-Output "Domain user SID: $sid"

              $tmpCfg = "$env:TEMP\secpol_export_$((Get-Random)).cfg"
              $tmpDb  = "$env:TEMP\secpol_$((Get-Random)).sdb"

              secedit /export /cfg $tmpCfg /quiet | Out-Null
              $content = Get-Content $tmpCfg -Raw

              if ($content -match 'SeBatchLogonRight\s*=\s*(.*)') {
                  $existing = $Matches[0]
                  if ($existing -notmatch [regex]::Escape($sid)) {
                      $content = $content -replace [regex]::Escape($existing), "$existing,*$sid"
                      Write-Output "Appended $domainUser to SeBatchLogonRight"
                  } else {
                      Write-Output "SeBatchLogonRight already contains $domainUser"
                  }
              } else {
                  $content = $content -replace '(\[Privilege Rights\])', "`$1`r`nSeBatchLogonRight = *$sid"
                  Write-Output "Added SeBatchLogonRight for $domainUser"
              }

              Set-Content $tmpCfg $content -Encoding ASCII
              secedit /configure /db $tmpDb /cfg $tmpCfg /quiet | Out-Null
              Remove-Item $tmpCfg, $tmpDb -Force -ErrorAction SilentlyContinue
              Write-Output "SeBatchLogonRight: OK"
          } catch {
              Write-Output "WARNING: SeBatchLogonRight grant failed — $($_.Exception.Message)"
              # Might already work via Domain Admins → Administrators group
          }

          # --- 2. ACL FullControl on work directory ---
          $acl  = Get-Acl $workDir
          $rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
              $domainUser, "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow")
          $acl.SetAccessRule($rule)
          Set-Acl $workDir $acl
          Write-Output "ACL FullControl on $workDir for $domainUser: OK"

    # ---- 1. Scrivi lo script completo di setup ----
    - name: Scrivi script di setup cluster + AG
      ansible.windows.win_copy:
        dest: "{{ work_dir }}\\setup_cluster.ps1"
        content: |
          # Transcript per diagnostica (cattura TUTTO anche se lo script crasha)
          Start-Transcript -Path "C:\Windows\Temp\ClusterSetup\transcript.log" -Force

          $ErrorActionPreference = 'Stop'
          $logFile  = "C:\Windows\Temp\ClusterSetup\cluster_setup.log"
          $exitFile = "C:\Windows\Temp\ClusterSetup\exitcode.txt"

          function Log { param([string]$msg)
            $ts = Get-Date -Format 'HH:mm:ss'
            $line = "$ts  $msg"
            Add-Content -Path $logFile -Value $line
            Write-Host $line
          }

          try {
              Log "=== Cluster + AG Setup ==="
              Log "Running as: $env:USERDOMAIN\$env:USERNAME"
              Log "Logon type test: whoami=$(whoami)"
              Log "Node1: {{ node1_fqdn }}  Node2: {{ node2_fqdn }}"
              Log "Cluster: {{ cluster_name }} ({{ cluster_ip }})"
              Log "AG: {{ ag_name }}   Listener(DNN): {{ listener_name }}"

              # ---- Phase 0: Prerequisites ----
              Log "--- Phase 0: Prerequisites ---"
              Log "Testing PSRemoting to {{ node2_fqdn }}..."
              $r = Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock { hostname }
              Log "PSRemoting OK — {{ node2_fqdn }} returned: $r"

              # Open firewall ports on both nodes
              foreach ($port in @(1433, 5022)) {
                  $ruleName = "SQL-$port"
                  New-NetFirewallRule -DisplayName $ruleName -Direction Inbound -LocalPort $port -Protocol TCP -Action Allow -ErrorAction SilentlyContinue | Out-Null
                  Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock {
                      param($n,$p)
                      New-NetFirewallRule -DisplayName $n -Direction Inbound -LocalPort $p -Protocol TCP -Action Allow -ErrorAction SilentlyContinue | Out-Null
                  } -ArgumentList $ruleName, $port
              }
              Log "Firewall rules (1433, 5022) OK on both nodes"

              # ---- Phase 1: Cluster Validation ----
              Log "--- Phase 1: Cluster Validation ---"
              Test-Cluster -Node "{{ node1_fqdn }}", "{{ node2_fqdn }}" -Include "Storage","Network","Inventory","Configuration" -ErrorAction Stop | Out-Null
              Log "Phase 1: PASSED"

              # ---- Phase 2: Create WSFC Cluster ----
              Log "--- Phase 2: Create WSFC Cluster ---"
              $clusterObj = $null
              try { $clusterObj = Get-Cluster -Name "{{ cluster_name }}" -ErrorAction Stop } catch {}
              if ($clusterObj) {
                  Log "Cluster '{{ cluster_name }}' already exists — skip"
              } else {
                  New-Cluster -Name "{{ cluster_name }}" `
                      -Node "{{ node1_fqdn }}", "{{ node2_fqdn }}" `
                      -StaticAddress "{{ cluster_ip }}" `
                      -NoStorage -ErrorAction Stop
                  Log "Cluster '{{ cluster_name }}' created"
              }

              # ---- Phase 3: Cloud Witness ----
              $saName = "{{ storage_account_name }}"
              $saKey  = "{{ storage_account_key }}"
              if ($saName -and $saKey) {
                  Log "--- Phase 3: Cloud Witness ---"
                  Set-ClusterQuorum -Cluster "{{ cluster_name }}" `
                      -CloudWitness -AccountName $saName -AccessKey $saKey -ErrorAction Stop
                  Log "Cloud Witness configured ($saName)"
              } else {
                  Log "--- Phase 3: Cloud Witness --- SKIPPED"
              }

              # ---- Phase 4: Enable SQL Always On ----
              Log "--- Phase 4: Enable SQL Always On ---"
              if (-not (Get-Module -ListAvailable SqlServer -ErrorAction SilentlyContinue)) {
                  Log "Installing SqlServer PS module..."
                  [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                  Install-PackageProvider -Name NuGet -Force -Scope AllUsers -ErrorAction SilentlyContinue | Out-Null
                  Install-Module SqlServer -Force -AllowClobber -Scope AllUsers -ErrorAction Stop
              }
              Import-Module SqlServer -ErrorAction Stop
              Log "SqlServer module loaded"

              Enable-SqlAlwaysOn -ServerInstance "{{ node1_fqdn }}" -Force -ErrorAction Stop
              Log "AlwaysOn enabled on {{ node1_fqdn }}"
              Enable-SqlAlwaysOn -ServerInstance "{{ node2_fqdn }}" -Force -ErrorAction Stop
              Log "AlwaysOn enabled on {{ node2_fqdn }}"

              # Restart SQL on both nodes
              Log "Restarting MSSQLSERVER on {{ node1_name }}..."
              Restart-Service -Name MSSQLSERVER -Force
              Log "Restarting MSSQLSERVER on {{ node2_name }}..."
              Invoke-Command -ComputerName "{{ node2_fqdn }}" -ScriptBlock {
                  Restart-Service -Name MSSQLSERVER -Force
              }

              # Wait for SQL to come online
              foreach ($inst in @("{{ node1_fqdn }}", "{{ node2_fqdn }}")) {
                  Log "Waiting for SQL on $inst..."
                  for ($retry = 1; $retry -le 24; $retry++) {
                      Start-Sleep -Seconds 5
                      try {
                          Invoke-Sqlcmd -ServerInstance $inst -Query "SELECT 1" -ErrorAction Stop | Out-Null
                          Log "SQL $inst is ONLINE"
                          break
                      } catch {
                          if ($retry -eq 24) { throw "SQL Server $inst not ready after 120 s" }
                      }
                  }
              }
              Log "Phase 4: DONE"

              # ---- Phase 5: Availability Group ----
              Log "--- Phase 5: Availability Group ---"
              $existingAg = $null
              try {
                  $existingAg = Get-ChildItem "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT\AvailabilityGroups" `
                      -ErrorAction Stop | Where-Object { $_.Name -eq "{{ ag_name }}" }
              } catch {}

              if ($existingAg) {
                  Log "AG '{{ ag_name }}' already exists — skip"
              } else {
                  # Hadr endpoint — node 1
                  try {
                      $ep1 = New-SqlHadrEndpoint -Path "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT" `
                          -Name "Hadr_endpoint" -Port 5022 -ErrorAction Stop
                      Set-SqlHadrEndpoint -Path "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT\Endpoints\Hadr_endpoint" -State Started
                  } catch { Log "Hadr_endpoint node1: $($_.Exception.Message) (may exist)" }
                  Log "Hadr_endpoint {{ node1_fqdn }} OK"

                  # Hadr endpoint — node 2
                  $ep2Q = "IF NOT EXISTS (SELECT 1 FROM sys.endpoints WHERE name='Hadr_endpoint') " +
                          "CREATE ENDPOINT Hadr_endpoint STATE=STARTED AS TCP(LISTENER_PORT=5022) " +
                          "FOR DATABASE_MIRRORING(ROLE=ALL, AUTHENTICATION=WINDOWS NEGOTIATE, ENCRYPTION=REQUIRED ALGORITHM AES)"
                  Invoke-Sqlcmd -ServerInstance "{{ node2_fqdn }}" -Query $ep2Q
                  Log "Hadr_endpoint {{ node2_fqdn }} OK"

                  # SQL major version (auto-detect)
                  $sqlVer = [int](Invoke-Sqlcmd -ServerInstance "{{ node1_fqdn }}" `
                      -Query "SELECT CAST(SERVERPROPERTY('ProductMajorVersion') AS INT) AS V").V
                  Log "SQL major version: $sqlVer"

                  $primary = New-SqlAvailabilityReplica -Name "{{ node1_fqdn }}" `
                      -EndpointUrl "TCP://{{ node1_fqdn }}:5022" `
                      -AvailabilityMode SynchronousCommit -FailoverMode Automatic `
                      -AsTemplate -Version $sqlVer
                  $secondary = New-SqlAvailabilityReplica -Name "{{ node2_fqdn }}" `
                      -EndpointUrl "TCP://{{ node2_fqdn }}:5022" `
                      -AvailabilityMode SynchronousCommit -FailoverMode Automatic `
                      -AsTemplate -Version $sqlVer

                  New-SqlAvailabilityGroup -Name "{{ ag_name }}" `
                      -Path "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT" `
                      -AvailabilityReplica @($primary, $secondary) -ErrorAction Stop
                  Log "AG '{{ ag_name }}' created"

                  # Join node 2
                  Join-SqlAvailabilityGroup -Path "SQLSERVER:\SQL\{{ node2_fqdn }}\DEFAULT" `
                      -Name "{{ ag_name }}" -ErrorAction Stop
                  Log "{{ node2_fqdn }} joined AG"
              }
              Log "Phase 5: DONE"

              # ---- Phase 6: DNN Listener ----
              Log "--- Phase 6: DNN Listener ---"
              $existingLsn = $null
              try {
                  $existingLsn = Get-ChildItem "SQLSERVER:\SQL\{{ node1_fqdn }}\DEFAULT\AvailabilityGroups\{{ ag_name }}\AvailabilityGroupListeners" `
                      -ErrorAction Stop | Where-Object { $_.Name -eq "{{ listener_name }}" }
              } catch {}

              if ($existingLsn) {
                  Log "DNN Listener '{{ listener_name }}' already exists — skip"
              } else {
                  $lsnQ = "ALTER AVAILABILITY GROUP [{{ ag_name }}] ADD LISTENER N'{{ listener_name }}' " +
                          "(WITH DISTRIBUTED_NETWORK_NAME, WITH IP (NONE), PORT = {{ listener_port }})"
                  Invoke-Sqlcmd -ServerInstance "{{ node1_fqdn }}" -Query $lsnQ
                  Log "DNN Listener '{{ listener_name }}' port {{ listener_port }}"
              }
              Log "Phase 6: DONE"

              Log "=== ALL PHASES COMPLETED ==="
              "0" | Out-File -FilePath $exitFile -Encoding ascii

          } catch {
              Log "FATAL: $($_.Exception.Message)"
              Log "Stack: $($_.ScriptStackTrace)"
              "1" | Out-File -FilePath $exitFile -Encoding ascii
          } finally {
              Stop-Transcript -ErrorAction SilentlyContinue
          }

    # ---- 2. Esegui via Scheduled Task ----
    - name: Esegui setup cluster via Scheduled Task (WinRM double-hop workaround)
      ansible.windows.win_powershell:
        script: |
          $taskName    = "AnsibleClusterSetup"
          $scriptPath  = "{{ work_dir }}\setup_cluster.ps1"
          $exitFile    = "{{ work_dir }}\exitcode.txt"
          $logFile     = "{{ work_dir }}\cluster_setup.log"
          $transcript  = "{{ work_dir }}\transcript.log"

          # Cleanup previous run
          foreach ($f in @($exitFile, $logFile, $transcript)) {
            if (Test-Path $f) { Remove-Item $f -Force }
          }
          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue

          # Register task with domain credentials (Batch logon → Kerberos TGT)
          $action   = New-ScheduledTaskAction -Execute "powershell.exe" `
              -Argument "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`""
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries `
              -DontStopIfGoingOnBatteries -ExecutionTimeLimit (New-TimeSpan -Minutes 40)
          Register-ScheduledTask -TaskName $taskName -Action $action -Settings $settings `
              -User "{{ domain_user }}" -Password "{{ domain_password }}" `
              -RunLevel Highest -Force | Out-Null

          Start-ScheduledTask -TaskName $taskName
          Write-Output "Scheduled task started — cluster setup in progress..."

          # Give the task a moment to actually start
          Start-Sleep -Seconds 5

          # Poll (max 35 min)
          $deadline = [DateTime]::UtcNow.AddMinutes(35)
          $firstPoll = $true
          do {
              if (-not $firstPoll) { Start-Sleep -Seconds 15 }
              $firstPoll = $false

              $task  = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue
              $info  = Get-ScheduledTaskInfo -TaskName $taskName -ErrorAction SilentlyContinue
              $state = $task.State
              $lastResult = if ($info) { "0x{0:X}" -f $info.LastTaskResult } else { "N/A" }
              $tail  = ""
              if (Test-Path $logFile) { $tail = (Get-Content $logFile -Tail 1) }
              Write-Output "  [state=$state result=$lastResult] $tail"

              # If task went to Ready and no exitcode, it failed to start
              if ($state -ne 'Running') {
                  Write-Output "Task is no longer Running (state=$state, lastResult=$lastResult)"
                  break
              }
          } while ([DateTime]::UtcNow -lt $deadline)

          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue

          # Show cluster setup log
          if (Test-Path $logFile) {
              Write-Output "=== Cluster Setup Log ==="
              Get-Content $logFile
              Write-Output "=== End Log ==="
          }

          # Show transcript if log is missing (captures parse errors, crashes, etc.)
          if (-not (Test-Path $logFile) -and (Test-Path $transcript)) {
              Write-Output "=== Transcript (no log produced) ==="
              Get-Content $transcript -Tail 50
              Write-Output "=== End Transcript ==="
          }

          # If no exitcode file, show Event Log for clues
          if (-not (Test-Path $exitFile)) {
              Write-Output "=== Task Scheduler Event Log (last 5) ==="
              Get-WinEvent -LogName "Microsoft-Windows-TaskScheduler/Operational" -MaxEvents 5 |
                  Where-Object { $_.Message -match $taskName } |
                  ForEach-Object { Write-Output "$($_.TimeCreated) [$($_.Id)] $($_.Message)" }
              Write-Output "=== End Event Log ==="
              Write-Error "Cluster setup did not produce exit code — task state=$state lastResult=$lastResult"
              exit 1
          }

          $ec = [int](Get-Content $exitFile -Raw).Trim()
          Write-Output "Exit code: $ec"
          if ($ec -ne 0) { Write-Error "Cluster setup failed — see log above"; exit 1 }
          Write-Output "Cluster + AG setup completed successfully"
      register: cluster_setup
      timeout: 2400

    - name: Mostra output completo
      ansible.builtin.debug:
        msg: "{{ cluster_setup.output | default(['N/A']) }}"

    # ---- 3. Riepilogo ----
    - name: Riepilogo finale
      ansible.builtin.debug:
        msg: |
          === Cluster + AG Summary ===
          Cluster:       {{ cluster_name }} ({{ cluster_ip }})
          Nodes:         {{ node1_fqdn }}, {{ node2_fqdn }}
          Cloud Witness: {{ storage_account_name | default('N/A') }}
          AG:            {{ ag_name }}
          DNN Listener:  {{ listener_name }} (port {{ listener_port }})
          Connection:    Server={{ listener_name }},{{ listener_port }};MultiSubnetFailover=True
